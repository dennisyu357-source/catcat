<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>å‰ä»–å’ªçš„éŸ³ä¹ä¹‹æ—…</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Zcool+KuaiLe&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #fff;
            overflow: hidden;
            font-family: 'Zcool KuaiLe', sans-serif, cursive; /* å¯çˆ±å­—ä½“ */
            touch-action: none; /* ç¦æ­¢æ‰‹æœºä¸‹æ‹‰åˆ·æ–° */
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        .title {
            font-size: 40px;
            color: #333;
            text-shadow: 2px 2px 0px #eee;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        .subtitle {
            font-size: 18px;
            color: #666;
            margin-bottom: 40px;
            background: rgba(255,255,255,0.8);
            padding: 5px 15px;
            border-radius: 20px;
        }

        .score-board {
            position: absolute;
            top: 20px;
            right: 20px;
            font-size: 24px;
            color: #333;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media (max-width: 600px) {
            .title { font-size: 32px; }
            .subtitle { font-size: 14px; }
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div id="start-screen">
            <div class="title">ğŸ¸ å‰ä»–å’ªçš„éŸ³ä¹ä¹‹æ—… ğŸµ</div>
            <div class="subtitle">ç‚¹å‡»å±å¹•æˆ–æŒ‰ç©ºæ ¼è·³è·ƒ</div>
            <div style="font-size: 20px; color: #ff6b6b; animation: blink 1s infinite;">ç‚¹å‡»ä»»æ„å¤„å¼€å§‹</div>
        </div>
        <div id="game-over-screen" style="display: none;">
            <div class="title">å“å‘€ï¼èµ°éŸ³äº†ï¼</div>
            <div class="subtitle" id="final-score">å¾—åˆ†: 0</div>
            <div style="font-size: 20px; color: #333;">ç‚¹å‡»é‡è¯•</div>
        </div>
    </div>

    <div class="score-board">âœ¨ <span id="score">0</span></div>
    <canvas id="gameCanvas"></canvas>

    <script>
        // --- æ¸¸æˆè®¾ç½®ä¸åˆå§‹åŒ– ---
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const uiLayer = document.getElementById('ui-layer');
        const startScreen = document.getElementById('start-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const scoreEl = document.getElementById('score');
        const finalScoreEl = document.getElementById('final-score');

        let width, height;
        let frameId;
        let score = 0;
        let gameSpeed = 5;
        let state = 'START'; // START, PLAYING, GAMEOVER

        // ç‰©ç†å‚æ•°
        const gravity = 0.6;
        const jumpStrength = -10; // è·³è·ƒåŠ›åº¦
        const groundHeight = 100;

        // è§’è‰²ï¼šå‰ä»–å’ª
        const mimi = {
            x: 50,
            y: 0,
            w: 60,
            h: 60,
            dy: 0,
            grounded: false,
            rotation: 0,
            phrase: "", // å£å¤´ç¦…
            phraseTimer: 0
        };

        // æ¸¸æˆå¯¹è±¡
        let obstacles = [];
        let stars = [];
        let particles = [];

        // éŸ³é¢‘ä¸Šä¸‹æ–‡ (Web Audio API)
        let audioCtx;
        const scale = [261.63, 293.66, 329.63, 392.00, 440.00, 523.25]; // Cå¤§è°ƒäº”å£°
        let noteIndex = 0;

        // --- æ ¸å¿ƒåŠŸèƒ½å‡½æ•° ---

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            mimi.y = height - groundHeight - mimi.h;
            mimi.x = width * 0.15; // å’ªçš„ä½ç½®åœ¨å±å¹•å·¦ä¾§15%
        }

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playGuitarNote() {
            if (!audioCtx) return;
            if (audioCtx.state === 'suspended') audioCtx.resume();

            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            
            // å‰ä»–éŸ³è‰²æ¨¡æ‹Ÿ (ç®€å•çš„ä¸‰è§’æ³¢+è¡°å‡)
            osc.type = 'triangle';
            osc.frequency.value = scale[noteIndex % scale.length];
            noteIndex++;

            gain.gain.setValueAtTime(0.2, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.5);

            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.5);
        }

        function playCrashSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.value = 100;
            osc.frequency.linearRampToValueAtTime(50, audioCtx.currentTime + 0.3);
            gain.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.3);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.3);
        }

        function playStarSound() {
            if (!audioCtx) return;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sine';
            osc.frequency.value = 880;
            gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
            gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.1);
        }

        // éšæœºæŠ–åŠ¨å‡½æ•° (æ¨¡ä»¿æ‰‹ç»˜çº¿æ¡)
        function j(val) {
            return val + (Math.random() - 0.5) * 2;
        }

        // ç»˜åˆ¶å‰ä»–å’ª
        function drawMimiChar(ctx, x, y, w, h) {
            ctx.save();
            ctx.translate(x + w/2, y + h/2);
            // è·‘æ­¥æ—¶çš„è½»å¾®æ‘‡æ‘†
            if (state === 'PLAYING' && mimi.grounded) {
                ctx.rotate(Math.sin(Date.now() / 100) * 0.1);
            } else {
                ctx.rotate(mimi.dy * 0.05); // è·³è·ƒæ—¶å€¾æ–œ
            }

            // èº«ä½“ (ç™½è‰²ï¼Œé»‘è‰²æè¾¹ï¼Œèœ¡ç¬”è´¨æ„Ÿ)
            ctx.beginPath();
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#222';
            ctx.lineWidth = 3;
            // ç®€å•çš„åœ†æ¶¦çŸ©å½¢æ¨¡æ‹ŸçŒ«èº«ä½“
            ctx.ellipse(0, 5, w/2, h/2 - 5, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();

            // è€³æœµ
            ctx.beginPath();
            ctx.moveTo(j(-20), j(-20));
            ctx.lineTo(j(-25), j(-35));
            ctx.lineTo(j(-10), j(-25));
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.stroke(); // å·¦è€³

            ctx.beginPath();
            ctx.moveTo(j(20), j(-20));
            ctx.lineTo(j(25), j(-35));
            ctx.lineTo(j(10), j(-25));
            ctx.fillStyle = '#fff';
            ctx.fill();
            ctx.stroke(); // å³è€³

            // çœ¼ç›
            ctx.fillStyle = '#000';
            ctx.beginPath(); ctx.arc(j(-10), j(-5), 3, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(j(10), j(-5), 3, 0, Math.PI*2); ctx.fill();

            // è…®çº¢
            ctx.fillStyle = '#ffb7b2';
            ctx.beginPath(); ctx.arc(j(-15), j(0), 4, 0, Math.PI*2); ctx.fill();
            ctx.beginPath(); ctx.arc(j(15), j(0), 4, 0, Math.PI*2); ctx.fill();

            // å‰ä»– (ç²‰è‰²)
            ctx.save();
            ctx.rotate(-0.2);
            ctx.fillStyle = '#ffafc0';
            ctx.strokeStyle = '#222';
            // å‰ä»–ç´èº«
            ctx.beginPath();
            ctx.arc(5, 15, 12, 0, Math.PI*2);
            ctx.fill(); ctx.stroke();
            // ç´é¢ˆ
            ctx.fillStyle = '#444';
            ctx.fillRect(10, 10, 25, 6);
            // ç´å¤´
            ctx.fillRect(35, 8, 5, 10);
            ctx.restore();

            // æ‰‹ (æ‹¿ç€å‰ä»–)
            ctx.strokeStyle = '#222';
            ctx.beginPath(); ctx.arc(-10, 10, 5, 0, Math.PI); ctx.stroke(); // å·¦æ‰‹
            ctx.beginPath(); ctx.arc(10, 12, 5, 0, Math.PI); ctx.stroke(); // å³æ‰‹

            ctx.restore();
        }

        // å£å¤´ç¦…æ°”æ³¡
        function drawBubble(ctx) {
            if (mimi.phraseTimer > 0) {
                mimi.phraseTimer--;
                const x = mimi.x + 40;
                const y = mimi.y - 30;
                
                ctx.save();
                ctx.font = "20px 'Zcool KuaiLe'";
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 2;
                
                const text = mimi.phrase;
                const textWidth = ctx.measureText(text).width;
                
                // æ°”æ³¡èƒŒæ™¯
                ctx.beginPath();
                ctx.roundRect(x, y - 20, textWidth + 20, 30, 10);
                ctx.fill();
                ctx.stroke();
                
                // æ–‡å­—
                ctx.fillStyle = '#000';
                ctx.fillText(text, x + 10, y + 2);
                ctx.restore();
            }
        }

        // æ¸¸æˆé€»è¾‘æ›´æ–°
        function update() {
            if (state !== 'PLAYING') return;

            // å¢åŠ éš¾åº¦
            gameSpeed += 0.002;

            // å’ªçš„ç‰©ç†
            mimi.dy += gravity;
            mimi.y += mimi.dy;

            // åœ°é¢ç¢°æ’
            if (mimi.y + mimi.h > height - groundHeight) {
                mimi.y = height - groundHeight - mimi.h;
                mimi.dy = 0;
                mimi.grounded = true;
            } else {
                mimi.grounded = false;
            }

            // ç”Ÿæˆéšœç¢ç‰© (èµ°éŸ³ç¬¦å·)
            if (Math.random() < 0.015) {
                obstacles.push({
                    x: width,
                    y: height - groundHeight - 40, // åœ°é¢éšœç¢
                    w: 30,
                    h: 40,
                    type: 'note' 
                });
            }

            // ç”Ÿæˆæ˜Ÿæ˜Ÿ
            if (Math.random() < 0.01) {
                stars.push({
                    x: width,
                    y: height - groundHeight - 100 - Math.random() * 100, // ç©ºä¸­
                    w: 30,
                    h: 30,
                    angle: 0
                });
            }

            // æ›´æ–°éšœç¢ç‰©
            for (let i = obstacles.length - 1; i >= 0; i--) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                // ç¢°æ’æ£€æµ‹
                if (
                    mimi.x < obs.x + obs.w - 10 &&
                    mimi.x + mimi.w > obs.x + 10 &&
                    mimi.y < obs.y + obs.h - 10 &&
                    mimi.y + mimi.h > obs.y + 10
                ) {
                    gameOver();
                }

                if (obs.x + obs.w < 0) obstacles.splice(i, 1);
            }

            // æ›´æ–°æ˜Ÿæ˜Ÿ
            for (let i = stars.length - 1; i >= 0; i--) {
                let star = stars[i];
                star.x -= gameSpeed;
                star.angle += 0.1;

                // æ”¶é›†æ£€æµ‹
                if (
                    mimi.x < star.x + star.w &&
                    mimi.x + mimi.w > star.x &&
                    mimi.y < star.y + star.h &&
                    mimi.y + mimi.h > star.y
                ) {
                    score += 10;
                    scoreEl.innerText = score;
                    stars.splice(i, 1);
                    createParticles(star.x, star.y, '#ffd700');
                    playStarSound();
                } else if (star.x + star.w < 0) {
                    stars.splice(i, 1);
                }
            }

            // æ›´æ–°ç²’å­
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.life--;
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function createParticles(x, y, color) {
            for (let i = 0; i < 8; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 10,
                    vy: (Math.random() - 0.5) * 10,
                    life: 30,
                    color: color
                });
            }
        }

        // ç»˜åˆ¶å¾ªç¯
        function draw() {
            ctx.clearRect(0, 0, width, height);

            // ç»˜åˆ¶åœ°é¢çº¿æ¡
            ctx.beginPath();
            ctx.moveTo(0, height - groundHeight);
            // æ‰‹ç»˜é£æ ¼åœ°é¢
            for(let i=0; i<width; i+=20) {
                ctx.lineTo(i, height - groundHeight + j(0));
            }
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ç»˜åˆ¶è£…é¥° (èƒŒæ™¯é‡Œçš„å°éŸ³ç¬¦)
            if (state === 'PLAYING' && Math.floor(Date.now() / 500) % 2 === 0) {
                // ç®€å•çš„èƒŒæ™¯åŠ¨æ•ˆ
            }

            // ç»˜åˆ¶éšœç¢ç‰© (æ¶‚é¸¦é£æ ¼çš„é»‘è‰²éŸ³ç¬¦)
            ctx.fillStyle = '#333';
            obstacles.forEach(obs => {
                ctx.font = "30px Arial";
                ctx.fillText("â™©", obs.x, obs.y + 30);
                // ä¹±ç³Ÿç³Ÿçš„çº¿è¡¨ç¤ºâ€œèµ°éŸ³â€
                ctx.strokeStyle = '#000';
                ctx.beginPath();
                ctx.moveTo(obs.x - 5, obs.y + 15);
                ctx.lineTo(obs.x + 35, obs.y + 15);
                ctx.stroke();
            });

            // ç»˜åˆ¶æ˜Ÿæ˜Ÿ
            stars.forEach(star => {
                ctx.save();
                ctx.translate(star.x + star.w/2, star.y + star.h/2);
                ctx.rotate(star.angle);
                ctx.fillStyle = '#ffd700';
                ctx.font = "30px Arial";
                ctx.fillText("â˜…", -15, 10);
                ctx.restore();
            });

            // ç»˜åˆ¶ç²’å­
            particles.forEach(p => {
                ctx.fillStyle = p.color;
                ctx.globalAlpha = p.life / 30;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3, 0, Math.PI*2);
                ctx.fill();
                ctx.globalAlpha = 1;
            });

            // ç»˜åˆ¶å’ª
            drawMimiChar(ctx, mimi.x, mimi.y, mimi.w, mimi.h);
            
            // ç»˜åˆ¶æ°”æ³¡
            drawBubble(ctx);
        }

        function loop() {
            update();
            draw();
            frameId = requestAnimationFrame(loop);
        }

        // --- æ¸¸æˆçŠ¶æ€æ§åˆ¶ ---

        function jump() {
            if (state !== 'PLAYING') return;
            
            if (mimi.grounded) {
                mimi.dy = jumpStrength;
                mimi.grounded = false;
                playGuitarNote(); // éŸ³ä¹å…ƒç´ ï¼šè·³è·ƒå³å¼¹å¥
                createParticles(mimi.x + mimi.w/2, mimi.y + mimi.h, '#ffafc0');
            }
        }

        function resetGame() {
            score = 0;
            gameSpeed = 5;
            obstacles = [];
            stars = [];
            particles = [];
            scoreEl.innerText = score;
            mimi.y = height - groundHeight - mimi.h;
            mimi.dy = 0;
            noteIndex = 0;
        }

        function startGame() {
            initAudio();
            state = 'PLAYING';
            startScreen.style.display = 'none';
            gameOverScreen.style.display = 'none';
            resetGame();
            
            // è§¦å‘å£å¤´ç¦…
            mimi.phrase = "å¥½å§ï¼";
            mimi.phraseTimer = 60; // æ˜¾ç¤º60å¸§ (çº¦1ç§’)
        }

        function gameOver() {
            state = 'GAMEOVER';
            playCrashSound();
            
            // è§¦å‘å£å¤´ç¦…
            mimi.phrase = "è®¨åŒä½ ï¼";
            mimi.phraseTimer = 120; 
            drawBubble(ctx); // å¼ºåˆ¶ç»˜åˆ¶ä¸€æ¬¡ç¡®ä¿çœ‹åˆ°

            setTimeout(() => {
                finalScoreEl.innerText = "å¾—åˆ†: " + score;
                gameOverScreen.style.display = 'block';
            }, 500);
        }

        // --- äº‹ä»¶ç›‘å¬ ---

        // ç»Ÿä¸€å¤„ç†ç‚¹å‡»å’Œè§¦æ‘¸
        function handleInput(e) {
            if (state === 'START' || state === 'GAMEOVER') {
                startGame();
            } else {
                jump();
            }
        }

        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space') handleInput();
        });

        window.addEventListener('touchstart', (e) => {
            e.preventDefault(); // é˜²æ­¢æ»šåŠ¨
            handleInput();
        }, {passive: false});

        window.addEventListener('mousedown', handleInput);

        window.addEventListener('resize', resize);

        // å¯åŠ¨
        resize();
        loop();

    </script>
</body>

</html>
